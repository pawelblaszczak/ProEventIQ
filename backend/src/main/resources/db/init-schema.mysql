-- AProEventIQ Database Schema
-- Created: June 17, 2025

-- Drop tables if they exist (in reverse order to avoid foreign key constraints)
DROP TABLE IF EXISTS seat;
DROP TABLE IF EXISTS seat_row;
DROP TABLE IF EXISTS sector;
DROP TABLE IF EXISTS venue;
DROP TABLE IF EXISTS event_show;
DROP TABLE IF EXISTS event;
DROP TABLE IF EXISTS participant;

-- Create venue table
CREATE TABLE venue (
    venue_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_name VARCHAR(100) NOT NULL,
    name VARCHAR(100) NOT NULL,
    country VARCHAR(100) NOT NULL,
    city VARCHAR(100) NOT NULL,
    address VARCHAR(255) NOT NULL,
    thumbnail MEDIUMBLOB,
    thumbnail_content_type VARCHAR(100),
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Create sector table
CREATE TABLE sector (
    sector_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    venue_id BIGINT NOT NULL,
    name VARCHAR(100) NOT NULL,
    order_number INT,
    position_x FLOAT,
    position_y FLOAT,
    rotation INT DEFAULT 0,
    price_category VARCHAR(50),
    status ENUM('active', 'inactive') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (venue_id) REFERENCES venue(venue_id) ON DELETE CASCADE
);

-- Create seat_row table
CREATE TABLE seat_row (
    seat_row_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    sector_id BIGINT NOT NULL,
    name VARCHAR(50) NOT NULL,
    order_number INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (sector_id) REFERENCES sector(sector_id) ON DELETE CASCADE,
    UNIQUE KEY unique_seat_row_in_sector (sector_id, order_number)
);

-- Create seat table
CREATE TABLE seat (
    seat_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    seat_row_id BIGINT NOT NULL,
    order_number INT NOT NULL,
    position_x FLOAT,
    position_y FLOAT,
    price_category VARCHAR(50),
    status ENUM('active', 'inactive') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (seat_row_id) REFERENCES seat_row(seat_row_id) ON DELETE CASCADE,
    UNIQUE KEY unique_seat_in_seat_row (seat_row_id, order_number)
);

-- Create indexes for better performance
CREATE INDEX idx_venue_country_city ON venue(country, city);
CREATE INDEX idx_sector_venue ON sector(venue_id);
CREATE INDEX idx_seat_row_sector ON seat_row(sector_id);
CREATE INDEX idx_seat_seat_row ON seat(seat_row_id);
CREATE INDEX idx_seat_status ON seat(status);

-- Create event_show table
CREATE TABLE event_show (
    show_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_name VARCHAR(100) NOT NULL,
    name VARCHAR(255) NOT NULL,
    thumbnail MEDIUMBLOB,
    thumbnail_content_type VARCHAR(100),
    description TEXT,
    age_from INT,
    age_to INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Create indexes for event_show table
CREATE INDEX idx_show_name ON event_show(name);
CREATE INDEX idx_show_age_range ON event_show(age_from, age_to);

-- Create event table
CREATE TABLE event (
    event_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_name VARCHAR(100) NOT NULL,
    show_id BIGINT NOT NULL,
    venue_id BIGINT NOT NULL,
    date_time DATETIME NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (show_id) REFERENCES event_show(show_id) ON DELETE CASCADE,
    FOREIGN KEY (venue_id) REFERENCES venue(venue_id) ON DELETE CASCADE
);

-- Create indexes for event table
CREATE INDEX idx_event_show_id ON event(show_id);
CREATE INDEX idx_event_venue_id ON event(venue_id);
CREATE INDEX idx_event_date_time ON event(date_time);

-- Create participant table
CREATE TABLE participant (
    participant_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    event_id BIGINT NOT NULL,
    name VARCHAR(255) NOT NULL,
    address VARCHAR(255),
    seat_color VARCHAR(7),
    children_ticket_count INT NOT NULL DEFAULT 0,
    guardian_ticket_count INT NOT NULL DEFAULT 0,
    all_ticket_count INT GENERATED ALWAYS AS (children_ticket_count + guardian_ticket_count) STORED,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (event_id) REFERENCES event(event_id) ON DELETE CASCADE,
    CHECK (all_ticket_count >= 1)
);

-- Create indexes for participant table
CREATE INDEX idx_participant_event_id ON participant(event_id);

DELIMITER $$

CREATE FUNCTION get_event_ticket_count(eventId VARCHAR(255)) RETURNS int
    DETERMINISTIC
BEGIN
  DECLARE total INT;
  SELECT SUM(all_ticket_count) INTO total
  FROM participant
  WHERE event_id = eventId;
  RETURN IFNULL(total, 0);
END$$



CREATE FUNCTION get_venue_seat_count(p_venue_id BIGINT) RETURNS int
    READS SQL DATA
    DETERMINISTIC
BEGIN
    DECLARE seat_count INT;
    SELECT COUNT(s.seat_id)
      INTO seat_count
      FROM seat s
      JOIN seat_row sr ON s.seat_row_id = sr.seat_row_id
      JOIN sector sec ON sr.sector_id = sec.sector_id
     WHERE sec.venue_id = p_venue_id;
    RETURN seat_count;
END$$

CREATE FUNCTION get_sector_seat_count(p_sector_id BIGINT) RETURNS INT
    READS SQL DATA
    DETERMINISTIC
BEGIN
    DECLARE seat_count INT;
    SELECT COUNT(s.seat_id)
      INTO seat_count
      FROM seat s
      JOIN seat_row sr ON s.seat_row_id = sr.seat_row_id
     WHERE sr.sector_id = p_sector_id;
    RETURN seat_count;
END$$

DELIMITER ;

CREATE TABLE seat_reservation (
    reservation_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    participant_id BIGINT NOT NULL,
    seat_id BIGINT NOT NULL,
    event_id BIGINT NOT NULL,
    reserved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (participant_id) REFERENCES participant(participant_id) ON DELETE CASCADE,
    FOREIGN KEY (seat_id) REFERENCES seat(seat_id) ON DELETE CASCADE,
    FOREIGN KEY (event_id) REFERENCES event(event_id) ON DELETE CASCADE,
    UNIQUE KEY unique_seat_event (seat_id, event_id) -- Prevent double booking of a seat for an event
);

CREATE TABLE seat_block (
    seat_block_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    event_id BIGINT NOT NULL,
    seat_id BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (event_id) REFERENCES event(event_id) ON DELETE CASCADE,
    FOREIGN KEY (seat_id) REFERENCES seat(seat_id) ON DELETE CASCADE,
    UNIQUE KEY unique_seat_block_event (seat_id, event_id)
);

CREATE TABLE user_details (
    id VARCHAR(50) PRIMARY KEY,
    email VARCHAR(50),
    name VARCHAR(200),
    address VARCHAR(500),
    thumbnail MEDIUMBLOB,
    thumbnail_content_type VARCHAR(100),
    UNIQUE KEY unique_email (email)
);





DELIMITER $$

CREATE FUNCTION get_event_blocked_seat_count(p_event_id BIGINT) RETURNS int
    READS SQL DATA
    DETERMINISTIC
BEGIN
    DECLARE blocked_count INT;
    SELECT COUNT(*) INTO blocked_count
    FROM seat_block
    WHERE event_id = p_event_id;
    RETURN IFNULL(blocked_count, 0);
END$$

CREATE FUNCTION has_allocation_errors(p_event_id BIGINT) RETURNS VARCHAR(1)
    READS SQL DATA
    DETERMINISTIC
BEGIN
    DECLARE v_total_tickets INT DEFAULT 0;
    DECLARE v_venue_id BIGINT;
    DECLARE v_venue_seats INT DEFAULT 0;
    DECLARE v_allocated INT DEFAULT 0;
    DECLARE v_has_error BOOLEAN DEFAULT FALSE;

    -- total tickets requested by all participants for the event
    SELECT IFNULL(SUM(all_ticket_count), 0) INTO v_total_tickets
    FROM participant
    WHERE event_id = p_event_id;

    -- find venue for event
    SELECT venue_id INTO v_venue_id
    FROM event
    WHERE event_id = p_event_id
    LIMIT 1;

    -- if event not found, consider it an error
    IF v_venue_id IS NULL THEN
        RETURN 'Y';
    END IF;

    -- total seats available in the venue
    SET v_venue_seats = get_venue_seat_count(v_venue_id);

    -- number of seats actually allocated (reservations) for the event
    SELECT COUNT(*) INTO v_allocated
    FROM seat_reservation
    WHERE event_id = p_event_id;

    -- Check 1: requested tickets exceed venue capacity
    IF v_total_tickets > v_venue_seats THEN
        SET v_has_error = TRUE;
    END IF;

    -- Check 2: allocated seats don't match requested tickets
    IF v_allocated <> v_total_tickets THEN
        SET v_has_error = TRUE;
    END IF;

    RETURN IF(v_has_error, 'Y', 'N');
END$$



DELIMITER ;

-- =============================================================
-- Procedure: copy_sector_seats
-- Purpose:   Copies the full seat layout (seat_rows + seats) from a
--            source sector to a destination sector. All existing
--            seat_rows (and cascading seats) in the destination sector
--            are removed first. Keeps order_number and names intact.
-- Params:    p_source_sector_id INT - sector to copy FROM
--            p_destination_sector_id INT - sector to copy TO
-- Notes:     - Aborts with an error if source == destination
--            - If source has no seat_rows, destination will simply be cleared
--            - Uses temporary tables for mapping old->new seat_row IDs
-- =============================================================
DELIMITER $$
CREATE PROCEDURE copy_sector_seats(IN p_source_sector_id BIGINT, IN p_destination_sector_id BIGINT)
MODIFIES SQL DATA
BEGIN
    -- Prevent accidental self-copy
    IF p_source_sector_id = p_destination_sector_id THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Source and destination sector must differ';
    END IF;
    -- Ensure temp tables from previous pooled-connection usage are gone
    DROP TEMPORARY TABLE IF EXISTS tmp_source_rows;
    DROP TEMPORARY TABLE IF EXISTS tmp_row_id_map;

    -- Clear destination (seat deletion cascades via FK when seat_rows removed)
    DELETE FROM seat_row WHERE sector_id = p_destination_sector_id;

    -- Capture source seat_rows (if any)
    CREATE TEMPORARY TABLE tmp_source_rows AS
        SELECT seat_row_id AS old_seat_row_id,
               name,
               order_number
          FROM seat_row
         WHERE sector_id = p_source_sector_id
         ORDER BY order_number;

    SET @row_count := (SELECT COUNT(*) FROM tmp_source_rows);

    IF @row_count > 0 THEN
        -- Insert new seat_rows for destination keeping order_number & name
        INSERT INTO seat_row (sector_id, name, order_number)
            SELECT p_destination_sector_id, name, order_number
              FROM tmp_source_rows
             ORDER BY order_number;

        -- Map old seat_row_ids to new ones via unique (sector_id, order_number)
        CREATE TEMPORARY TABLE tmp_row_id_map AS
            SELECT s.old_seat_row_id,
                   r.seat_row_id AS new_seat_row_id
              FROM tmp_source_rows s
              JOIN seat_row r ON r.sector_id = p_destination_sector_id
                              AND r.order_number = s.order_number;

        -- Copy seats using the mapping
        INSERT INTO seat (seat_row_id, order_number, position_x, position_y, price_category, status)
            SELECT m.new_seat_row_id,
                   st.order_number,
                   st.position_x,
                   st.position_y,
                   st.price_category,
                   st.status
              FROM seat st
              JOIN tmp_row_id_map m ON st.seat_row_id = m.old_seat_row_id
             ORDER BY m.new_seat_row_id, st.order_number;
    END IF;

    -- Drop temp tables explicitly so pooled connection stays clean
    DROP TEMPORARY TABLE IF EXISTS tmp_row_id_map;
    DROP TEMPORARY TABLE IF EXISTS tmp_source_rows;
END$$
DELIMITER ;





