-- AProEventIQ Database Schema
-- Created: June 17, 2025

-- Drop tables if they exist (in reverse order to avoid foreign key constraints)
DROP TABLE IF EXISTS seat;
DROP TABLE IF EXISTS seat_row;
DROP TABLE IF EXISTS sector;
DROP TABLE IF EXISTS venue;
DROP TABLE IF EXISTS event_show;
DROP TABLE IF EXISTS event;
DROP TABLE IF EXISTS participant;

-- Create venue table
CREATE TABLE venue (
    venue_id INT AUTO_INCREMENT PRIMARY KEY,
    user_name VARCHAR(100) NOT NULL,
    name VARCHAR(100) NOT NULL,
    country VARCHAR(100) NOT NULL,
    city VARCHAR(100) NOT NULL,
    address VARCHAR(255) NOT NULL,
    thumbnail MEDIUMBLOB,
    thumbnail_content_type VARCHAR(100),
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Create sector table
CREATE TABLE sector (
    sector_id INT AUTO_INCREMENT PRIMARY KEY,
    venue_id INT NOT NULL,
    name VARCHAR(100) NOT NULL,
    order_number INT,
    position_x FLOAT,
    position_y FLOAT,
    rotation INT DEFAULT 0,
    price_category VARCHAR(50),
    status ENUM('active', 'inactive') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (venue_id) REFERENCES venue(venue_id) ON DELETE CASCADE
);

-- Create seat_row table
CREATE TABLE seat_row (
    seat_row_id INT AUTO_INCREMENT PRIMARY KEY,
    sector_id INT NOT NULL,
    name VARCHAR(50) NOT NULL,
    order_number INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (sector_id) REFERENCES sector(sector_id) ON DELETE CASCADE,
    UNIQUE KEY unique_seat_row_in_sector (sector_id, order_number)
);

-- Create seat table
CREATE TABLE seat (
    seat_id INT AUTO_INCREMENT PRIMARY KEY,
    seat_row_id INT NOT NULL,
    order_number INT NOT NULL,
    position_x FLOAT,
    position_y FLOAT,
    price_category VARCHAR(50),
    status ENUM('active', 'inactive') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (seat_row_id) REFERENCES seat_row(seat_row_id) ON DELETE CASCADE,
    UNIQUE KEY unique_seat_in_seat_row (seat_row_id, order_number)
);

-- Create indexes for better performance
CREATE INDEX idx_venue_country_city ON venue(country, city);
CREATE INDEX idx_sector_venue ON sector(venue_id);
CREATE INDEX idx_seat_row_sector ON seat_row(sector_id);
CREATE INDEX idx_seat_seat_row ON seat(seat_row_id);
CREATE INDEX idx_seat_status ON seat(status);

-- Create event_show table
CREATE TABLE event_show (
    show_id INT AUTO_INCREMENT PRIMARY KEY,
    user_name VARCHAR(100) NOT NULL,
    name VARCHAR(255) NOT NULL,
    thumbnail MEDIUMBLOB,
    thumbnail_content_type VARCHAR(100),
    description TEXT,
    age_from INT,
    age_to INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Create indexes for event_show table
CREATE INDEX idx_show_name ON event_show(name);
CREATE INDEX idx_show_age_range ON event_show(age_from, age_to);

-- Create event table
CREATE TABLE event (
    event_id INT AUTO_INCREMENT PRIMARY KEY,
    user_name VARCHAR(100) NOT NULL,
    show_id INT NOT NULL,
    venue_id INT NOT NULL,
    date_time DATETIME NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (show_id) REFERENCES event_show(show_id) ON DELETE CASCADE,
    FOREIGN KEY (venue_id) REFERENCES venue(venue_id) ON DELETE CASCADE
);

-- Create indexes for event table
CREATE INDEX idx_event_show_id ON event(show_id);
CREATE INDEX idx_event_venue_id ON event(venue_id);
CREATE INDEX idx_event_date_time ON event(date_time);

-- Create participant table
CREATE TABLE participant (
    participant_id INT AUTO_INCREMENT PRIMARY KEY,
    event_id INT NOT NULL,
    name VARCHAR(255) NOT NULL,
    address VARCHAR(255),
    seat_color VARCHAR(7),
    number_of_tickets INT NOT NULL CHECK (number_of_tickets >= 1),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (event_id) REFERENCES event(event_id) ON DELETE CASCADE
);

-- Create indexes for participant table
CREATE INDEX idx_participant_event_id ON participant(event_id);

DELIMITER $$

CREATE FUNCTION get_event_ticket_count(eventId VARCHAR(255)) RETURNS int
    DETERMINISTIC
BEGIN
  DECLARE total INT;
  SELECT SUM(number_of_tickets) INTO total
  FROM participant
  WHERE event_id = eventId;
  RETURN IFNULL(total, 0);
END$$

CREATE FUNCTION get_venue_seat_count(p_venue_id INT) RETURNS int
    READS SQL DATA
    DETERMINISTIC
BEGIN
    DECLARE seat_count INT;
    SELECT COUNT(s.seat_id)
      INTO seat_count
      FROM seat s
      JOIN seat_row sr ON s.seat_row_id = sr.seat_row_id
      JOIN sector sec ON sr.sector_id = sec.sector_id
     WHERE sec.venue_id = p_venue_id;
    RETURN seat_count;
END$$

CREATE FUNCTION get_sector_seat_count(p_sector_id INT) RETURNS INT
    READS SQL DATA
    DETERMINISTIC
BEGIN
    DECLARE seat_count INT;
    SELECT COUNT(s.seat_id)
      INTO seat_count
      FROM seat s
      JOIN seat_row sr ON s.seat_row_id = sr.seat_row_id
     WHERE sr.sector_id = p_sector_id;
    RETURN seat_count;
END$$

DELIMITER ;

CREATE TABLE seat_reservation (
    reservation_id INT AUTO_INCREMENT PRIMARY KEY,
    participant_id INT NOT NULL,
    seat_id INT NOT NULL,
    event_id INT NOT NULL,
    reserved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (participant_id) REFERENCES participant(participant_id) ON DELETE CASCADE,
    FOREIGN KEY (seat_id) REFERENCES seat(seat_id) ON DELETE CASCADE,
    FOREIGN KEY (event_id) REFERENCES event(event_id) ON DELETE CASCADE,
    UNIQUE KEY unique_seat_event (seat_id, event_id) -- Prevent double booking of a seat for an event
);

CREATE TABLE user_details (
    id VARCHAR(50) PRIMARY KEY,
    email VARCHAR(50),
    name VARCHAR(200),
    address VARCHAR(500),
    thumbnail MEDIUMBLOB,
    thumbnail_content_type VARCHAR(100),
    UNIQUE KEY unique_email (email)
);





DELIMITER $$

CREATE FUNCTION has_allocation_errors(p_event_id INT) RETURNS VARCHAR(1)
    READS SQL DATA
    DETERMINISTIC
BEGIN
    DECLARE v_total_tickets INT DEFAULT 0;
    DECLARE v_venue_id INT;
    DECLARE v_venue_seats INT DEFAULT 0;
    DECLARE v_allocated INT DEFAULT 0;
    DECLARE v_has_error BOOLEAN DEFAULT FALSE;

    -- total tickets requested by all participants for the event
    SELECT IFNULL(SUM(number_of_tickets), 0) INTO v_total_tickets
    FROM participant
    WHERE event_id = p_event_id;

    -- find venue for event
    SELECT venue_id INTO v_venue_id
    FROM event
    WHERE event_id = p_event_id
    LIMIT 1;

    -- if event not found, consider it an error
    IF v_venue_id IS NULL THEN
        RETURN 'Y';
    END IF;

    -- total seats available in the venue
    SET v_venue_seats = get_venue_seat_count(v_venue_id);

    -- number of seats actually allocated (reservations) for the event
    SELECT COUNT(*) INTO v_allocated
    FROM seat_reservation
    WHERE event_id = p_event_id;

    -- Check 1: requested tickets exceed venue capacity
    IF v_total_tickets > v_venue_seats THEN
        SET v_has_error = TRUE;
    END IF;

    -- Check 2: allocated seats don't match requested tickets
    IF v_allocated <> v_total_tickets THEN
        SET v_has_error = TRUE;
    END IF;

    RETURN IF(v_has_error, 'Y', 'N');
END$$

DELIMITER ;





