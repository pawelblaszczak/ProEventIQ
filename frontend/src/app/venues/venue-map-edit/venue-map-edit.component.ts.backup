import { ChangeDetectionStrategy, Component, effect, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatDividerModule } from '@angular/material/divider';
import { MatDialogModule } from '@angular/material/dialog';
import { MatSnackBarModule, MatSnackBar } from '@angular/material/snack-bar';
import { MatMenuModule } from '@angular/material/menu';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatTooltipModule } from '@angular/material/tooltip';
import { NgxKonvaModule } from 'ngx-konva';
import { firstValueFrom } from 'rxjs';
import { Venue } from '../../api/model/venue';
import { Sector } from '../../api/model/sector';
import { ProEventIQService } from '../../api/api/pro-event-iq.service';
import { ConfirmationDialogService } from '../../shared';

interface EditableSector extends Sector {
  isSelected: boolean;
  isDragging: boolean;
  rotation: number;
}

@Component({
  selector: 'app-venue-map-edit',
  standalone: true,  imports: [
    CommonModule,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatDividerModule,
    MatDialogModule,
    MatSnackBarModule,
    MatMenuModule,
    MatToolbarModule,
    MatTooltipModule,
    NgxKonvaModule,
    RouterModule
  ],
  templateUrl: './venue-map-edit.component.html',
  styleUrls: ['./venue-map-edit.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class VenueMapEditComponent {
  private readonly route = inject(ActivatedRoute);
  private readonly router = inject(Router);
  private readonly venueApi = inject(ProEventIQService);
  private readonly confirmationDialog = inject(ConfirmationDialogService);
  private readonly snackBar = inject(MatSnackBar);

  private readonly venueId = signal<string | null>(null);
  public venue = signal<Venue | null>(null);
  public loading = signal(true);
  public error = signal<string | null>(null);
  public saving = signal(false);
  
  // Canvas and zoom settings
  zoom = signal(1);
  canvasWidth = 1200;
  canvasHeight = 800;
  
  // Edit state
  editableSectors = signal<EditableSector[]>([]);
  selectedSector = signal<EditableSector | null>(null);
  editMode = signal<'select' | 'add' | 'move' | 'rotate'>('select');
  hasChanges = signal(false);
  
  // Grid settings
  showGrid = signal(true);
  gridSize = 20;

  constructor() {
    this.route.paramMap.subscribe(params => {
      const venueId = params.get('venueId');
      this.venueId.set(venueId);
      if (venueId) {
        this.fetchVenue(venueId);
      }
    });
    
    // Resize canvas initially and on window resize
    this.resizeCanvas();
    window.addEventListener('resize', () => {
      this.resizeCanvas();
    });

    // Track changes for unsaved work warning
    effect(() => {
      if (this.hasChanges()) {
        window.addEventListener('beforeunload', this.handleBeforeUnload);
      } else {
        window.removeEventListener('beforeunload', this.handleBeforeUnload);
      }
    });
  }

  private resizeCanvas() {
    // Set canvas to responsive size
    this.canvasWidth = Math.max(window.innerWidth - 400, 800); // Account for sidebar
    this.canvasHeight = Math.max(window.innerHeight * 0.7, 600);
  }

  private readonly handleBeforeUnload = (event: BeforeUnloadEvent) => {
    if (this.hasChanges()) {
      event.preventDefault();
      return 'You have unsaved changes. Are you sure you want to leave?';
    }
    return undefined;
  };

  private fetchVenue(id: string) {
    this.loading.set(true);
    this.venueApi.getVenue(id).subscribe({
      next: (venue: Venue) => {
        this.venue.set(venue);
        this.initializeEditableSectors(venue);
        this.loading.set(false);
      },
      error: (err: any) => {
        this.error.set('Failed to load venue.');
        this.loading.set(false);
        console.error('Error loading venue data:', err);
      }
    });
  }
  private initializeEditableSectors(venue: Venue) {
    if (venue.sectors) {
      const editableSectors: EditableSector[] = venue.sectors.map(sector => ({
        ...sector,
        isSelected: false,
        isDragging: false,
        rotation: 0,
        // Ensure position exists with default values
        position: sector.position ?? { x: 100, y: 100 }
      }));
      this.editableSectors.set(editableSectors);
    }
  }

  // Zoom controls
  zoomIn() {
    const newZoom = Math.min(this.zoom() * 1.2, 3);
    this.zoom.set(newZoom);
  }

  zoomOut() {
    const newZoom = Math.max(this.zoom() / 1.2, 0.5);
    this.zoom.set(newZoom);
  }

  resetZoom() {
    this.zoom.set(1);
  }

  // Edit mode controls
  setEditMode(mode: 'select' | 'add' | 'move' | 'rotate') {
    this.editMode.set(mode);
    this.selectedSector.set(null);
  }

  // Sector selection
  selectSector(sector: EditableSector) {
    const sectors = this.editableSectors();
    const updatedSectors = sectors.map(s => ({
      ...s,
      isSelected: s.sectorId === sector.sectorId
    }));
    this.editableSectors.set(updatedSectors);
    this.selectedSector.set(sector);
  }

  deselectAll() {
    const sectors = this.editableSectors();
    const updatedSectors = sectors.map(s => ({
      ...s,
      isSelected: false
    }));
    this.editableSectors.set(updatedSectors);
    this.selectedSector.set(null);
  }
  // Sector movement
  onSectorDragStart(sector: EditableSector) {
    this.selectSector(sector);
    const sectors = this.editableSectors();
    const updatedSectors = sectors.map(s => ({
      ...s,
      isDragging: s.sectorId === sector.sectorId
    }));
    this.editableSectors.set(updatedSectors);
  }

  onSectorDragEnd(sector: EditableSector, event: any) {
    const sectors = this.editableSectors();
    const position = event.target.position();
    
    const updatedSectors = sectors.map(s => {
      if (s.sectorId === sector.sectorId) {
        return {
          ...s,
          isDragging: false,
          position: { x: Math.round(position.x), y: Math.round(position.y) }
        };
      }
      return { ...s, isDragging: false };
    });
    
    this.editableSectors.set(updatedSectors);
    this.hasChanges.set(true);
  }
  // Sector rotation
  rotateSector(clockwise: boolean = true) {
    const selected = this.selectedSector();
    if (!selected) return;

    const sectors = this.editableSectors();
    const rotationStep = clockwise ? 15 : -15;
    
    const updatedSectors = sectors.map(s => {
      if (s.sectorId === selected.sectorId) {
        const newRotation = ((s.rotation ?? 0) + rotationStep) % 360;
        return { ...s, rotation: newRotation };
      }
      return s;
    });
    
    this.editableSectors.set(updatedSectors);
    this.hasChanges.set(true);
  }  // Add new sector
  addNewSector() {
    console.log('Adding new sector...');
    const sectors = this.editableSectors();
    const newSector: EditableSector = {
      sectorId: `temp-${Date.now()}`,
      name: `Sector ${sectors.length + 1}`,
      position: { x: 200, y: 200 },
      numberOfSeats: 0,
      priceCategory: 'Standard',
      status: Sector.StatusEnum.Active,
      isSelected: true,
      isDragging: false,
      rotation: 0
    };

    // Deselect all others and add new sector
    const updatedSectors = sectors.map(s => ({ ...s, isSelected: false }));
    updatedSectors.push(newSector);
    
    this.editableSectors.set(updatedSectors);
    this.selectedSector.set(newSector);
    this.hasChanges.set(true);
    console.log('New sector added:', newSector);
  }
  // Delete sector
  deleteSector() {
    const selected = this.selectedSector();
    if (!selected) return;

    this.confirmationDialog.confirmDelete(selected.name ?? 'this sector', 'sector')
      .subscribe(confirmed => {
        if (confirmed) {
          const sectors = this.editableSectors();
          const updatedSectors = sectors.filter(s => s.sectorId !== selected.sectorId);
          this.editableSectors.set(updatedSectors);
          this.selectedSector.set(null);
          this.hasChanges.set(true);
        }
      });
  }
  // Duplicate sector
  duplicateSector() {
    const selected = this.selectedSector();
    if (!selected) return;

    const sectors = this.editableSectors();
    const duplicatedSector: EditableSector = {
      ...selected,
      sectorId: `temp-${Date.now()}`,
      name: `${selected.name} Copy`,
      position: {
        x: (selected.position?.x ?? 0) + 50,
        y: (selected.position?.y ?? 0) + 50
      },
      isSelected: true,
      isDragging: false,
      rotation: 0
    };

    // Deselect all others and add duplicated sector
    const updatedSectors = sectors.map(s => ({ ...s, isSelected: false }));
    updatedSectors.push(duplicatedSector);
    
    this.editableSectors.set(updatedSectors);
    this.selectedSector.set(duplicatedSector);
    this.hasChanges.set(true);
  }

  // Navigation
  goBack() {
    this.navigateBack();
  }

  // Helper methods for position values
  getSectorPositionValue(sector: EditableSector, property: 'x' | 'y'): number {
    return sector.position?.[property] ?? 0;
  }

  // Get sector color based on selection and status
  getSectorColor(sector: EditableSector): string {
    if
